// api/metrics/storeMetrics.ts
import type { User, RedeemedItem } from '../../types';
import { calculateDiscountedPrice } from '../economy/economy';

/**
 * Finds the most frequently purchased items from the store.
 * @param redeemedItems - The log of all redeemed items.
 * @returns A sorted list of items by purchase count.
 */
export const getMostPurchasedItems = (redeemedItems: RedeemedItem[]) => {
    const counts = redeemedItems.reduce((acc, item) => {
        acc[item.itemName] = (acc[item.itemName] || 0) + 1;
        return acc;
    }, {} as Record<string, number>);

    return Object.entries(counts)
        .map(([name, count]) => ({ name, count }))
        .sort((a, b) => b.count - a.count);
};

/**
 * Calculates the total revenue generated by the store in Lummi Coins (LC).
 * @param redeemedItems - The log of all redeemed items.
 * @returns The total LC spent by users in the store.
 */
export const calculateStoreRevenueInLC = (redeemedItems: RedeemedItem[]) => {
    return redeemedItems.reduce((sum, item) => sum + item.itemPrice, 0);
};

/**
 * Detects potential abuse of the store, such as impossible purchases.
 * @param users - All users in the system.
 * @param redeemedItems - The log of all redeemed items.
 * @returns An array of alerts for suspicious store activity.
 */
export const detectStoreAbuse = (users: User[], redeemedItems: RedeemedItem[]) => {
    const alerts: { userId: string, reason: string, details: string }[] = [];

    for (const item of redeemedItems) {
        // Anomaly 1: Impossible purchase (coins after redemption are higher than before)
        if (item.coinsAfter > item.coinsBefore) {
            alerts.push({
                userId: item.userId,
                reason: 'Compra impossível (saldo aumentou)',
                details: `Item "${item.itemName}" resgatado, mas o saldo de LC aumentou de ${item.coinsBefore} para ${item.coinsAfter}.`
            });
        }
    }

    // Anomaly 2: Repeated purchases of the same item in a short time
    const purchasesByUser: Record<string, RedeemedItem[]> = redeemedItems.reduce((acc, item) => {
        if (!acc[item.userId]) acc[item.userId] = [];
        acc[item.userId].push(item);
        return acc;
    }, {});

    for (const userId in purchasesByUser) {
        const userPurchases = purchasesByUser[userId].sort((a,b) => new Date(a.redeemedAtISO).getTime() - new Date(b.redeemedAtISO).getTime());
        for (let i = 0; i < userPurchases.length - 2; i++) {
            // 3 purchases of the same item within 1 hour
            if (
                userPurchases[i].itemId === userPurchases[i+1].itemId &&
                userPurchases[i].itemId === userPurchases[i+2].itemId &&
// FIX: Add a fallback value of 0 when creating Date objects from `redeemedAtISO` properties. This prevents "Invalid Date" errors if the string is empty or malformed, ensuring that time-based calculations for detecting store abuse are robust and do not cause runtime exceptions.
                new Date(userPurchases[i+2].redeemedAtISO || 0).getTime() - new Date(userPurchases[i].redeemedAtISO || 0).getTime() < 60 * 60 * 1000
            ) {
                 alerts.push({
                    userId: userId,
                    reason: 'Compras repetidas em curto período',
                    details: `Usuário comprou o item "${userPurchases[i].itemName}" 3 vezes em menos de 1 hora.`
                });
                break; // Only flag once per user
            }
        }
    }

    return alerts;
};